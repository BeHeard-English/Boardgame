<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>English Adventure with Be Heard</title>
    <link href="https://fonts.googleapis.com/css2?family=Itim&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Default: Bright & Cute */
            --bg-color: #fffaf0;
            --container-bg: #ffffff;
            --vocab-grad: linear-gradient(135deg, #a1c4fd 0%, #c2e9fb 100%);
            --pos-grad: linear-gradient(135deg, #d9d2e9 0%, #b4a7d6 100%);
            --neg-grad: linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%);
            --text-main: #ff6b6b;
            --text-tile: #2c3e50;
            --border-color: #ffd1dc;
        }

        body {
            font-family: 'Itim', cursive;
            background-color: var(--bg-color);
            margin: 0; padding: 0;
            transition: all 0.5s ease;
        }

        #setup-page, #game-page { display: flex; flex-direction: column; align-items: center; padding: 30px; box-sizing: border-box; min-height: 100vh; }
        #game-page { display: none; }

        .container {
            background: var(--container-bg);
            padding: 30px; border-radius: 30px;
            box-shadow: 0 15px 35px rgba(0,0,0,0.1);
            width: 90%; max-width: 700px; text-align: center;
            border: 4px solid var(--border-color);
        }

        h1 { color: var(--text-main); font-size: 3rem; margin: 0 0 20px 0; }

        textarea {
            width: 100%; height: 180px; border: 3px solid var(--border-color);
            border-radius: 20px; padding: 20px; font-family: 'Itim', cursive;
            font-size: 1.2rem; margin-bottom: 20px; box-sizing: border-box; outline: none;
        }

        .controls-bar {
            display: flex; flex-wrap: wrap; justify-content: center; gap: 15px;
            background: rgba(255,255,255,0.9); padding: 15px 25px;
            border-radius: 100px; box-shadow: 0 5px 15px rgba(0,0,0,0.1); margin-bottom: 25px;
            position: sticky; top: 10px; z-index: 100;
        }

        button {
            padding: 12px 28px; border: none; border-radius: 50px;
            font-family: 'Itim', cursive; font-weight: bold; font-size: 1.1rem;
            cursor: pointer; transition: all 0.2s; box-shadow: 0 4px 0 rgba(0,0,0,0.1);
        }

        .btn-primary { background: #ff8e8e; color: white; }
        .btn-dice { background: #4ecdc4; color: white; }
        .btn-shuffle { background: #ffbe0b; color: white; }
        .btn-back { background: #bdc3c7; color: white; }
        
        button:hover { transform: translateY(-2px); filter: brightness(1.1); }
        button:active { transform: translateY(2px); box-shadow: none; }

        #dice-res { font-size: 3.5rem; font-weight: bold; color: #4ecdc4; margin-left: 15px; min-width: 50px; }

        /* Board */
        #board {
            display: grid; grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 15px; width: 100%; max-width: 1200px; margin-bottom: 30px;
        }

        .tile {
            aspect-ratio: 1/1; border-radius: 20px; border: 5px solid white;
            display: flex; align-items: center; justify-content: center;
            font-size: 2.8rem; cursor: pointer; position: relative;
            box-shadow: 0 8px 15px rgba(0,0,0,0.1); transition: 0.3s;
        }
        .tile:hover { transform: scale(1.05); }
        .tile-vocab { background: var(--vocab-grad); }
        .tile-positive { background: var(--pos-grad); }
        .tile-negative { background: var(--neg-grad); }
        .tile-start { background: #ffffff; color: #ff6b6b; font-size: 1.2rem; font-weight: bold; }
        .tile-num { position: absolute; top: 5px; left: 10px; font-size: 0.9rem; opacity: 0.4; color: #000; }

        .theme-select {
            padding: 10px 15px; border-radius: 50px; border: 2px solid var(--border-color);
            font-family: 'Itim', cursive; outline: none; cursor: pointer;
        }

        /* Modal */
        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none; justify-content: center;
            align-items: center; z-index: 1000; backdrop-filter: blur(5px);
        }
        .modal-content {
            background: white; padding: 50px; border-radius: 40px; text-align: center;
            width: 85%; max-width: 800px; border: 10px solid var(--border-color);
        }
        .modal-text { font-size: 5rem; font-weight: bold; color: #222; margin-bottom: 20px; line-height: 1.2; }
        .modal-sub { font-size: 1.8rem; color: var(--text-main); margin-bottom: 10px; }
    </style>
</head>
<body>

    <div id="setup-page">
        <h1>üç≠ Let's play with Be Heard</h1>
        <div class="container">
            <p>Nh·∫≠p t·ª´ v·ª±ng/c√¢u h·ªèi b√™n d∆∞·ªõi</p>
            <textarea id="vocabInput" placeholder="V√≠ d·ª•:&#10;Apple&#10;Banana&#10;1. Cat&#10;- Dog"></textarea>
            <div style="margin-bottom: 20px;">
                üéµ Nh·∫°c n·ªÅn: <input type="file" id="bgMusic" accept="audio/*">
            </div>
            <button class="btn-primary" onclick="initGame()">üöÄ Let's Start</button>
        </div>
    </div>

    <div id="game-page">
        <div class="controls-bar">
            <div style="display: flex; align-items: center; border-right: 2px solid #ddd; padding-right: 20px;">
                <button class="btn-dice" onclick="rollDice()">üé≤ Roll the dice</button>
                <div id="dice-res">?</div>
            </div>
            <div style="display: flex; align-items: center; gap: 10px; padding: 0 10px;">
                <span>Theme:</span>
                <select class="theme-select" id="themeSelector" onchange="changeTheme(this.value)">
                    <option value="cute">üå∏ Cute</option>
                    <option value="action">üî• Action</option>
                    <option value="nature">üåø Fresh</option>
                    <option value="space">üåå Mystery</option>
                    <option value="vibrant">‚ö° Vivid</option>
                </select>
            </div>
            <button class="btn-shuffle" onclick="shuffleAndRebuildBoard()">üîÄ Shuffle</button>
            <button class="btn-back" onclick="goBack()">‚¨Ö Return</button>
        </div>

        <div id="board"></div>
    </div>

    <div id="modal-overlay" onclick="closeModal()">
        <div class="modal-content" onclick="event.stopPropagation()">
            <div id="modal-sub" class="modal-sub">D·∫°ng √¥</div>
            <div id="modal-text" class="modal-text">N·ªôi dung</div>
            <button class="btn-primary" style="font-size: 1.5rem;" onclick="closeModal()">Xong!</button>
        </div>
    </div>

    <audio id="bgAudio" loop></audio>

    <script>
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        let vocabList = [];
        let shuffledVocabList = []; // Danh s√°ch t·ª´ v·ª±ng ƒë√£ ƒë∆∞·ª£c x√°o tr·ªôn
        const TOTAL_TILES = 45;

        const themes = {
            cute: { bg: '#fffaf0', container: '#ffffff', main: '#ff6b6b', border: '#ffd1dc', vocab: 'linear-gradient(135deg, #a1c4fd, #c2e9fb)', pos: 'linear-gradient(135deg, #b4a7d6, #d9d2e9)', neg: 'linear-gradient(135deg, #ff9a9e, #fecfef)', tileText: '#2c3e50' },
            action: { bg: '#121212', container: '#1e1e1e', main: '#ff4757', border: '#333', vocab: 'linear-gradient(135deg, #cacfd9, #57606f)', pos: 'linear-gradient(135deg, #ff4757, #ff6b81)', neg: 'linear-gradient(135deg, #2f3542, #000)', tileText: '#fff' },
            nature: { bg: '#f1f8e9', container: '#fff', main: '#2e7d32', border: '#a5d6a7', vocab: 'linear-gradient(135deg, #d4fc79, #96e6a1)', pos: 'linear-gradient(135deg, #f991ac, #f4cccc)', neg: 'linear-gradient(135deg, #f6d365, #fda085)', tileText: '#1b5e20' },
            space: { bg: '#0b0e14', container: '#161b22', main: '#7d5fff', border: '#30363d', vocab: 'linear-gradient(135deg, #d9d2e9, #a1c4fd)', pos: 'linear-gradient(135deg, #00d2ff, #3a7bd5)', neg: 'linear-gradient(135deg, #6a11cb, #2575fc)', tileText: '#fff' },
            vibrant: { bg: '#fff5e6', container: '#fff', main: '#f39c12', border: '#f1c40f', vocab: 'linear-gradient(135deg, #ff9a00, #ff5a00)', pos: 'linear-gradient(135deg, #fad02e, #f28c28)', neg: 'linear-gradient(135deg, #ff0055, #ff00aa)', tileText: '#fff' }
        };

        function changeTheme(key) {
            const t = themes[key];
            const root = document.documentElement;
            root.style.setProperty('--bg-color', t.bg);
            root.style.setProperty('--container-bg', t.container);
            root.style.setProperty('--text-main', t.main);
            root.style.setProperty('--border-color', t.border);
            root.style.setProperty('--vocab-grad', t.vocab);
            root.style.setProperty('--pos-grad', t.pos);
            root.style.setProperty('--neg-grad', t.neg);
            root.style.setProperty('--text-tile', t.tileText);
        }

        function playSound(type) {
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;
            if(type === 'positive') { osc.frequency.setValueAtTime(523, now); osc.frequency.exponentialRampToValueAtTime(1046, now+0.2); gain.gain.setValueAtTime(0.1, now); }
            else if(type === 'negative') { osc.frequency.setValueAtTime(200, now); osc.frequency.linearRampToValueAtTime(50, now+0.4); gain.gain.setValueAtTime(0.2, now); }
            else { osc.frequency.setValueAtTime(440, now); gain.gain.setValueAtTime(0.05, now); }
            osc.start(); osc.stop(now+0.4);
        }

        // H√†m x√°o tr·ªôn m·∫£ng (Fisher-Yates algorithm)
        function shuffleArray(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }

        function initGame() {
            const input = document.getElementById('vocabInput').value;
            vocabList = input.split('\n').map(l => l.replace(/^[0-9.\-\*‚Ä¢\s]+/, '').trim()).filter(l => l !== "");
            if(vocabList.length === 0) {
                vocabList = ["Enter vocabulary in setup page"];
            }
            
            // X√°o tr·ªôn t·ª´ v·ª±ng ngay t·ª´ ƒë·∫ßu
            shuffledVocabList = shuffleArray(vocabList);
            
            document.getElementById('setup-page').style.display = 'none';
            document.getElementById('game-page').style.display = 'flex';
            buildBoard();
        }

        // H√†m x√°o tr·ªôn v√† rebuild board
        function shuffleAndRebuildBoard() {
            // X√°o tr·ªôn l·∫°i danh s√°ch t·ª´ v·ª±ng
            shuffledVocabList = shuffleArray(vocabList);
            // X√¢y d·ª±ng l·∫°i board
            buildBoard();
        }

        function shuffleWithConstraints(arr) {
            if (arr.length <= 1) return arr;
            
            let shuffled = [...arr];
            let hasBadSequence = true;
            let attempts = 0;
            const maxAttempts = 1000;
            
            while (hasBadSequence && attempts < maxAttempts) {
                // Tr·ªôn ng·∫´u nhi√™n
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                
                // Ki·ªÉm tra: kh√¥ng c√≥ 2 √¥ c√πng lo·∫°i (pos/pos ho·∫∑c neg/neg) li√™n ti·∫øp
                hasBadSequence = false;
                for (let i = 1; i < shuffled.length; i++) {
                    const current = shuffled[i];
                    const prev = shuffled[i-1];
                    
                    // Ch·ªâ ki·ªÉm tra positive v√† negative
                    if ((current === 'positive' || current === 'negative') && 
                        (prev === 'positive' || prev === 'negative')) {
                        // N·∫øu c·∫£ hai ƒë·ªÅu l√† ch·ª©c nƒÉng v√† c√πng lo·∫°i -> kh√¥ng h·ª£p l·ªá
                        if (current === prev) {
                            hasBadSequence = true;
                            break;
                        }
                    }
                }
                
                attempts++;
            }
            
            // N·∫øu sau nhi·ªÅu l·∫ßn v·∫´n kh√¥ng ƒë∆∞·ª£c, ch·∫•p nh·∫≠n k·∫øt qu·∫£ hi·ªán t·∫°i
            return shuffled;
        }

        function buildBoard() {
            const board = document.getElementById('board');
            board.innerHTML = "";
            let tiles = [];

            // 1. √î START c·ªë ƒë·ªãnh
            const startTile = { type: 'start', content: 'START', icon: 'üèÅ', sub: 'Let\'s Go!' };
            tiles.push(startTile);

            // 2. T·∫°o danh s√°ch lo·∫°i √¥
            const totalTiles = TOTAL_TILES;
            const tilesToCreate = totalTiles - 1;
            
            // ƒê·∫£m b·∫£o c√≥ ƒë·ªß t·ª´ v·ª±ng (n·∫øu √≠t th√¨ l·∫∑p l·∫°i)
            let vocabForBoard = [];
            
            // T·∫°o pool t·ª´ v·ª±ng ƒë·ªß d√πng t·ª´ danh s√°ch ƒë√£ x√°o tr·ªôn
            while (vocabForBoard.length < tilesToCreate) {
                vocabForBoard = vocabForBoard.concat([...shuffledVocabList]);
            }
            
            // X√°o tr·ªôn th√™m m·ªôt l·∫ßn n·ªØa ƒë·ªÉ ƒë·∫£m b·∫£o ng·∫´u nhi√™n
            vocabForBoard = shuffleArray(vocabForBoard);
            
            // 3. T·∫°o m·∫£ng ph√¢n ph·ªëi √¥
            let tileDistribution = [];
            
            // √î 2-4 (index 1-3): Lu√¥n l√† vocab (3 √¥ ƒë·∫ßu)
            for (let i = 0; i < 3; i++) {
                tileDistribution.push('vocab');
            }
            
            // √î gi·ªØa (index 4-41): Ph√¢n ph·ªëi ng·∫´u nhi√™n c√≥ ki·ªÉm so√°t
            const middleCount = totalTiles - 1 - 6; // Tr·ª´ START v√† 6 √¥ vocab ƒë·∫ßu/cu·ªëi
            
            // T·ª∑ l·ªá: 40% ch·ª©c nƒÉng (positive/negative), 60% vocab
            const funcCount = Math.floor(middleCount * 0.4);
            const vocabInMiddle = middleCount - funcCount;
            
            // T·∫°o m·∫£ng cho ph·∫ßn gi·ªØa
            let middleTiles = [];
            
            // Th√™m √¥ ch·ª©c nƒÉng
            const posCount = Math.floor(funcCount / 2);
            const negCount = funcCount - posCount;
            
            for (let i = 0; i < posCount; i++) middleTiles.push('positive');
            for (let i = 0; i < negCount; i++) middleTiles.push('negative');
            for (let i = 0; i < vocabInMiddle; i++) middleTiles.push('vocab');
            
            // Tr·ªôn v·ªõi r√†ng bu·ªôc
            middleTiles = shuffleWithConstraints(middleTiles);
            tileDistribution = tileDistribution.concat(middleTiles);
            
            // √î cu·ªëi (3 √¥ vocab)
            for (let i = 0; i < 3; i++) {
                tileDistribution.push('vocab');
            }
            
            // 4. Chu·∫©n b·ªã icon v√† n·ªôi dung
            const posIcons = ['üöÄ','‚≠ê','üéÅ','üèÜ','üåà','üíé','üî•','üç¨'];
            const negIcons = ['üêå','üå™Ô∏è','üßä','üëª','‚õàÔ∏è','üåßÔ∏è','üß®','üìâ'];
            
            let vocabIndex = 0;
            let lastPosValue = '';
            let lastNegValue = '';
            
            // 5. T·∫°o n·ªôi dung cho t·ª´ng √¥ d·ª±a tr√™n ph√¢n ph·ªëi
            tileDistribution.forEach((type) => {
                let tileData;
                
                switch(type) {
                    case 'vocab':
                        tileData = {
                            type: 'vocab',
                            content: vocabForBoard[vocabIndex % vocabForBoard.length],
                            icon: '',
                            sub: "VOCABULARY"
                        };
                        vocabIndex++;
                        break;
                        
                    case 'positive':
                        let posContent;
                        do {
                            if (Math.random() > 0.5) {
                                const steps = Math.min(rand(3) + 1, 4);
                                posContent = `Forward ${steps} Steps`;
                            } else {
                                const points = Math.min(rand(2) + 1, 3);
                                posContent = `+${points} Points`;
                            }
                        } while (posContent === lastPosValue);
                        lastPosValue = posContent;
                        
                        tileData = {
                            type: 'positive',
                            content: posContent,
                            icon: posIcons[rand(posIcons.length) - 1],
                            sub: "LUCKY!"
                        };
                        break;
                        
                    case 'negative':
                        let negContent;
                        do {
                            if (Math.random() > 0.5) {
                                const steps = Math.min(rand(3), 3);
                                negContent = `Back ${steps} Steps`;
                            } else {
                                const points = Math.min(rand(2) + 1, 3);
                                negContent = `-${points} Points`;
                            }
                        } while (negContent === lastNegValue);
                        lastNegValue = negContent;
                        
                        tileData = {
                            type: 'negative',
                            content: negContent,
                            icon: negIcons[rand(negIcons.length) - 1],
                            sub: "OH NO!"
                        };
                        break;
                }
                
                tiles.push(tileData);
            });

            // 6. Hi·ªÉn th·ªã (START ƒë√£ c√≥ ·ªü v·ªã tr√≠ 0)
            tiles.forEach((data, i) => {
                const el = document.createElement('div');
                el.className = `tile tile-${data.type}`;
                el.innerHTML = `<span class="tile-num">${i+1}</span>${data.icon}`;
                
                el.onclick = () => {
                    if(data.type !== 'start') {
                        playSound(data.type);
                        document.getElementById('modal-text').innerText = data.content.toUpperCase();
                        document.getElementById('modal-sub').innerText = data.sub;
                        document.getElementById('modal-overlay').style.display = 'flex';
                    }
                };
                board.appendChild(el);
            });
        }

        function rand(m) { return Math.floor(Math.random() * m) + 1; }
        
        function closeModal() { 
            document.getElementById('modal-overlay').style.display = 'none'; 
        }
        
        function goBack() { 
            document.getElementById('game-page').style.display = 'none'; 
            document.getElementById('setup-page').style.display = 'flex'; 
        }
        
        function rollDice() {
            const res = document.getElementById('dice-res');
            let c = 0; 
            res.style.opacity = "0.5";
            const t = setInterval(() => { 
                res.innerText = rand(6); 
                if(c++ > 12) {
                    clearInterval(t);
                    res.style.opacity = "1";
                    res.innerText = rand(6);
                } 
            }, 60);
        }

        document.getElementById('bgMusic').onchange = (e) => {
            const aud = document.getElementById('bgAudio');
            aud.src = URL.createObjectURL(e.target.files[0]); aud.play();
        };
    </script>
</body>
</html>